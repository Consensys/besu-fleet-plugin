import groovy.transform.Memoized

/*
 * Copyright ConsenSys 2023
 *]
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

buildscript {
    repositories {
        mavenLocal()
        mavenCentral()
        maven {
            url "https://artifacts.consensys.net/public/maven/maven/"
            content { includeGroupByRegex('tech\\.pegasys\\..*')}
        }
    }
    dependencies {
        classpath 'tech.pegasys.internal.license.reporter:license-reporter:1.1.1'
    }
}

plugins {
    id 'com.diffplug.spotless' version '6.25.0'
    id 'com.github.ben-manes.versions' version '0.51.0'
    id 'com.github.hierynomus.license' version '0.16.1'
    id 'io.spring.dependency-management' version '1.1.5'
    id 'com.github.jk1.dependency-license-report' version '2.8'
    id 'net.ltgt.errorprone' version '4.0.1' apply false
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'java'
    id 'java-library'
    id 'com.jfrog.artifactory' version '5.2.5'
    id 'maven-publish'
}


apply plugin: 'java-library'
apply plugin: 'io.spring.dependency-management'
apply plugin: 'net.ltgt.errorprone'
apply plugin: 'jacoco'
apply from: "${rootDir}/gradle/versions.gradle"
apply from: "${rootDir}/gradle/check-licenses.gradle"

def artifactoryUser = project.hasProperty('artifactoryUser') ? project.property('artifactoryUser') : System.getenv('ARTIFACTORY_USER')
def artifactoryPassword  = project.hasProperty('artifactoryPassword') ? project.property('artifactoryPassword') : System.getenv('ARTIFACTORY_PASSWORD')
def artifactoryRepo = System.getenv('ARTIFACTORY_REPO') ? System.getenv('ARTIFACTORY_REPO') : 'maven-local'
def artifactoryOrg = System.getenv('ARTIFACTORY_ORG') ? System.getenv('ARTIFACTORY_ORG') : 'consensys'

group = 'net.consensys.fleet.besu.plugin'
//version = '0.1.0'
version = project.hasProperty('releaseVersion') ? project.getProperty('releaseVersion') : 'snapshot'

sourceCompatibility = JavaVersion.VERSION_21
targetCompatibility = JavaVersion.VERSION_21

defaultTasks 'build', 'checkLicenses', 'javadoc', 'plugin'

repositories {
    mavenLocal()
    mavenCentral()
    maven {
        url "https://artifacts.consensys.net/public/maven/maven/"
        content { includeGroupByRegex('tech\\.pegasys($|\\..*)') }
    }
    maven {
        url "https://dl.cloudsmith.io/public/libp2p/jvm-libp2p/maven/"
        content { includeGroupByRegex('io\\.libp2p($|\\..*)') }
    }
    maven {
        url "https://hyperledger.jfrog.io/artifactory/besu-maven/"
        content { includeGroupByRegex('org\\.hyperledger\\.besu($|\\..*)') }
    }
    maven {
        url "https://${artifactoryOrg}.jfrog.io/artifactory/${artifactoryRepo}/"
    }
}

apply plugin: 'com.diffplug.spotless'
spotless {
    java {
        // This path needs to be relative to each project
        target fileTree('.') {
            include '**/*.java'
            exclude '**/.gradle/**'
            exclude '**/resources'
            exclude '**/src/*/generated'
            exclude '**/src/*/generated_tests'
            exclude '**/build/**'
        }
        removeUnusedImports()
        googleJavaFormat('1.17.0')
        importOrder 'net.consensys', 'java', ''
        trimTrailingWhitespace()
        endWithNewline()
        licenseHeaderFile "${rootDir}/gradle/spotless.java.license"
    }
}

tasks.withType(JavaCompile) {
    options.compilerArgs += [
            '-Xlint:unchecked',
            '-Xlint:cast',
            '-Xlint:rawtypes',
            '-Xlint:overloads',
            '-Xlint:divzero',
            '-Xlint:finally',
            '-Xlint:static',
            '-Werror',
    ]
    options.forkOptions.jvmArgs += [
            '--add-opens=jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',
            '--add-opens=jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',
            '--add-opens=jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED'
    ]

    options.errorprone {
        enabled = !'true'.equalsIgnoreCase(System.getProperty('avt.disableErrorProne'))
        disableWarningsInGeneratedCode
// Our equals need to be symmetric, this checker doesn't respect that
        check('FutureReturnValueIgnored', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // Our equals need to be symmetric, this checker doesn't respect that
        check('EqualsGetClass', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // We use the JSR-305 annotations instead of the Google annotations
        check('ImmutableEnumChecker', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // Storing a lambda to avoid code duplication is not a bad thing
        check('UnnecessaryLambda', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        // Generates a ton of false alarms for no real value
        check('LongDoubleConversion', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('InlineMeSuggester', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('CanIgnoreReturnValueSuggester', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('DirectInvocationOnMock', net.ltgt.gradle.errorprone.CheckSeverity.OFF)

        // We don't apply strict javadoc requirements yet
        check('EmptyBlockTag', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('MissingSummary', net.ltgt.gradle.errorprone.CheckSeverity.OFF)

        // Force strict compliance with Java naming conventions
        check('JavaCase', net.ltgt.gradle.errorprone.CheckSeverity.WARN)

        // Check for uses of == that should probably be .equals
        check('ReferenceComparison', net.ltgt.gradle.errorprone.CheckSeverity.WARN)

        // These checks are imported from errorprone-checks dependency but not required in Teku
        check('MethodInputParametersMustBeFinal', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('BannedMethod', net.ltgt.gradle.errorprone.CheckSeverity.OFF)
        check('ExperimentalCliOptionMustBeCorrectlyDisplayed', net.ltgt.gradle.errorprone.CheckSeverity.OFF)

        // These are experimental checks that we want enabled
        check('MissingBraces', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('InsecureCryptoUsage', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('WildcardImport', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('DeduplicateConstants', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('RedundantOverride', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('RedundantThrows', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('UnnecessarilyFullyQualified', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('InitializeInline', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('ClassName', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('InterfaceWithOnlyStatics', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
        check('PackageLocation', net.ltgt.gradle.errorprone.CheckSeverity.WARN)
    }
    options.encoding = 'UTF-8'
}

dependencies {
    // annotationProcessor generates the file META-INF/services/org.hyperledger.besu.plugin.BesuPlugin
    annotationProcessor 'com.google.auto.service:auto-service'
    compileOnly 'com.google.auto.service:auto-service-annotations'
    compileOnly 'com.google.guava:guava'

    errorprone("com.google.errorprone:error_prone_core")
    errorprone("tech.pegasys.tools.epchecks:errorprone-checks")

    api 'org.slf4j:slf4j-api'
    implementation 'org.apache.logging.log4j:log4j-slf4j2-impl'
    implementation 'org.apache.logging.log4j:log4j-core'


    implementation 'org.hyperledger.besu.internal:pipeline'
    implementation 'org.hyperledger.besu.internal:rlp'
    implementation 'org.hyperledger.besu:plugin-api'
    implementation 'org.hyperledger.besu:besu-datatypes'
    implementation 'info.picocli:picocli'


    implementation 'io.vertx:vertx-web-client'
    implementation 'io.vertx:vertx-web'

    implementation 'com.fasterxml.jackson.core:jackson-databind'
    implementation 'com.fasterxml.jackson.core:jackson-annotations'

    testImplementation 'org.assertj:assertj-core'
    testImplementation 'org.junit.jupiter:junit-jupiter'
    testImplementation 'org.assertj:assertj-core'
    testImplementation 'org.junit.jupiter:junit-jupiter-params'
    testImplementation 'org.mockito:mockito-core'
    testImplementation 'org.mockito:mockito-junit-jupiter'
    testImplementation 'io.vertx:vertx-junit5'
}

apply plugin: 'java'

jar {
    archiveBaseName = 'besu-fleet-plugin'

    manifest {
        attributes(
                'Specification-Title': archiveBaseName.get(),
                'Specification-Version': rootProject.version,
                'Implementation-Title': archiveBaseName.get(),
                'Implementation-Version': calculateVersion()
        )
    }

    from { configurations.runtimeClasspath.collect { it.isDirectory() ? it : zipTree(it) } }
    exclude 'META-INF/*.RSA', 'META-INF/*.SF', 'META-INF/*.DSA'
    duplicatesStrategy(DuplicatesStrategy.INCLUDE)
}

test {
    useJUnitPlatform()
}

task plugin(dependsOn: 'jar') {
    group 'build'
    description 'Alias for the jar task'
}

task printVersion() {
  doFirst {
    println "specific-version=${calculateVersion()}"
    println "publish-version=${project.version}"
  }
}

@Memoized
def calculateVersion() {
    String version = rootProject.version
    if (version.endsWith("-SNAPSHOT")) {
        version = version.replace("-SNAPSHOT", "-dev-" + getCheckedOutGitCommitHash())
    }
    return version
}

def getCheckedOutGitCommitHash(length = 8) {
    try {
        def gitFolder = "$projectDir/.git/"
        if (!file(gitFolder).isDirectory()) {
            // We are in a submodule.  The file's contents are `gitdir: <gitFolder>\n`.
            // Read the file, cut off the front, and trim the whitespace.
            gitFolder = file(gitFolder).text.substring(length).trim() + "/"
        }
        def takeFromHash = length
        /*
         * '.git/HEAD' contains either
         *      in case of detached head: the currently checked out commit hash
         *      otherwise: a reference to a file containing the current commit hash
         */
        def head = new File(gitFolder + "HEAD").text.split(":") // .git/HEAD
        def isCommit = head.length == 1 // e5a7c79edabbf7dd39888442df081b1c9d8e88fd

        if (isCommit) return head[0].trim().take(takeFromHash) // e5a7c79edabb

        def refHead = new File(gitFolder + head[1].trim()) // .git/refs/heads/master
        refHead.text.trim().take takeFromHash
    } catch (Exception e) {
        logger.warn('Could not calculate git commit, using "xxxxxxxx" (run with --info for stacktrace)')
        logger.info('Error retrieving git commit', e)
        return "xxxxxxxx"
    }
}

artifactory {
    publish {
        contextUrl = "https://${artifactoryOrg}.jfrog.io/artifactory"
        repository {
            repoKey = "${artifactoryRepo}"
            username = "${artifactoryUser}"
            password = "${artifactoryPassword}"
        }

        defaults {
            publications('mavenJava')
            publishArtifacts = true
            publishPom = true
        }
    }
}

publishing {
    publications {
        mavenJava(MavenPublication) {
            from components.java


            // Following configuration needed as without this artifactoryPublish fails due to dependency versions not available
            versionMapping {
                usage('java-api') {
                    fromResolutionOf('runtimeClasspath')
                }
                usage('java-runtime') {
                    fromResolutionResult()
                }
            }
        }
    }
}